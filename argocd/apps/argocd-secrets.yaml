apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: main-repo-creds
  namespace: argocd
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager # Nazwa Twojego SecretStore (musi istnieć)
    kind: SecretStore
  target:
    name: k8s-repo # Nazwa wynikowego sekretu
    creationPolicy: Owner
    template:
      type: Opaque
      metadata:
        labels:
          # To mówi ArgoCD: "Użyj tego do łączenia się z repozytorium"
          argocd.argoproj.io/secret-type: repository
      data:
        # ArgoCD Image Updater wymaga tych samych uprawnień co samo ArgoCD
        # więc ten jeden sekret załatwia obie sprawy.
        insecure: "false"
        enableLfs: "true"
  data:
  - secretKey: url
    remoteRef:
      key: argocd/repo-credentials
      property: url
  - secretKey: sshPrivateKey
    remoteRef:
      key: argocd/repo-credentials
      property: sshPrivateKey

# apiVersion: v1
# kind: Secret
# metadata:
#   name: k8s-repo
#   namespace: argocd
#   labels:
#     argocd.argoproj.io/secret-type: repository
# stringData:
#   url: git@github.com:k-napiontek/my-app.git
#   sshPrivateKey: |
#     -----BEGIN OPENSSH PRIVATE KEY-----
#     b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
#     QyNTUxOQAAACDhv8rT/wDUeF+rZjapWEk2RvEwv6Z19slUA2rzZJ5jYwAAAKDVFx6e1Rce
#     ngnAAAAtzc2gtZWQyNTUxOQAAACDhv8rT/wDUeF+rZjapWEk2RvEwv6Z19slUA2rzZJ5jYw
#     AAAEDzxvRDUq4N3GR1qVNkWOY1GQZ1bvi67weLgGElWA4n3OG/ytP/ANR4X6tmNqlYSTZG
#     8TC/pnX2yVQDavNknmNjAAAAHW5hcGlvbnRlay5rYXJvbDIwMDVAZ21haWwuY29t
#     -----END OPENSSH PRIVATE KEY-----
#   insecure: "false"
#   enableLfs: "true"